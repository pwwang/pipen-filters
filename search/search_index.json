{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"api/pipen_filters.filters/","text":"module pipen_filters . filters </> Provides the filters Functions add_filter ( aliases ) (Callable) \u2014 Add a filter to the FILTERS </> as_path ( pth ) (pathlib.path | panpath.cloud.cloudpath) \u2014 Convert a path to a Path object </> basename ( pth ) (str) \u2014 Get the basename of a path </> commonprefix ( *paths , basename_only ) (str) \u2014 Get the common prefix of a set of paths </> config ( x , loader ) (Mapping) \u2014 Get the configuration (python dictionary) from a file </> dirname ( pth ) (str) \u2014 Get the directory name of a path </> exists ( pth ) (bool) \u2014 Check if a path exists </> ext ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file </> ext0 ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file without the leading dot </> filename ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file. </> filename0 ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file without the extension </> getatime ( pth ) (int) \u2014 Get the access time of a file, return -1 if the file does not exist </> getctime ( pth ) (int) \u2014 Get the creation time of a file, return -1 if the file does not exist </> getmtime ( pth ) (int) \u2014 Get the modification time of a file, return -1 if the file does not exist </> getsize ( pth ) (int) \u2014 Get the size of a file, return -1 if the file does not exist </> glob ( pathsegment , *pathsegments ) (List) \u2014 Glob a path </> glob0 ( *paths ) (str) \u2014 Glob a path and return the first result </> isdir ( pth ) (bool) \u2014 Check if a path is a directory </> isempty ( pth , ignore_ws , nonfile_as_empty ) (bool) \u2014 Check if a file is empty </> isfile ( pth ) (bool) \u2014 Check if a path is a file </> islink ( pth ) (bool) \u2014 Check if a path is a symlink </> joinpaths ( pathsegment , *pathsegments ) (str) \u2014 Join paths. </> json_dumps ( var ) (str) \u2014 Dump an object to json. </> json_load ( pth ) (Any) \u2014 Load a json file </> json_loads ( jsonstr ) (Any) \u2014 Load a json string to an object </> prefix ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file </> prefix0 ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file without the extension </> quote ( var , quote_none ) (str) \u2014 Quote a string </> read ( file , *args , **kwargs ) (Union) \u2014 Read the contents from a file </> readlines ( file , *args , **kwargs ) (Union) \u2014 Read the lines from a file </> readlink ( pth ) (str) \u2014 Get the link of a symlink </> realpath ( pth ) (str) \u2014 Get the real path of a path </> regex_replace ( string , pattern , repl , count , flags ) (str) \u2014 Replace the matched pattern with a string </> slugify ( string , *args , **kwargs ) (str) \u2014 Slugify a string </> squote ( var , quote_none ) (str) \u2014 Quote a string with single quotes </> toml ( var ) (str) \u2014 Dump an object to toml. </> toml_load ( pth ) (Any) \u2014 Load a toml file. null will be loaded as None </> toml_loads ( tomlstr ) (Any) \u2014 Load a toml string to an object, null will be loaded as None </> function pipen_filters.filters . add_filter ( aliases=None ) </> Add a filter to the FILTERS Examples Filters added: myfilter >>> @add_filter ... def myfilter ( var ): ... return var >>> @add_filter () ... def myfilter ( var ): ... return var Filters added: myfilter , myfilter2 >>> @add_filter ( \"myfilter2\" ) ... def myfilter ( var ): ... return var Parameters aliases (Union, optional) \u2014 The aliases of the filter, the filter itself, or None Returns (Callable) The filter itself if used directly @add_filter ; orThe decorator to add the filter if used with arguments @add_filter(...) function pipen_filters.filters . realpath ( pth ) </> Get the real path of a path Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The real path of the file function pipen_filters.filters . readlink ( pth ) </> Get the link of a symlink Parameters pth (str | os.pathlike) \u2014 The path to the symlink Returns (str) The link of the symlink function pipen_filters.filters . commonprefix ( *paths , basename_only=True ) </> Get the common prefix of a set of paths Examples >>> commonprefix ( \"/a/b/abc.txt\" , \"/a/b/abc.png\" ) >>> # \"abc.\" >>> commonprefix ( \"/a/b/abc.txt\" , \"/a/b/abc.png\" , basename_only = False ) >>> # \"/a/b/abc.\" Parameters *paths (str | os.pathlike) \u2014 The paths to find commonprefix agaist basename_only (bool, optional) \u2014 Only search on the basenames Returns (str) The common prefix of the paths function pipen_filters.filters . dirname ( pth ) </> Get the directory name of a path For example, /a/b/c.txt => /a/b/ Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The directory name of the file function pipen_filters.filters . basename ( pth ) </> Get the basename of a path For example, /a/b/c.txt => c.txt Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The basename of the file function pipen_filters.filters . ext ( pth , ignore=[] , recursive=False ) </> Get the extension of a file For example, /a/b/c.txt => .txt . Aliases: suffix Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The extension of the file function pipen_filters.filters . ext0 ( pth , ignore=[] , recursive=False ) </> Get the extension of a file without the leading dot For example, /a/b/c.txt => txt . Aliases: suffix0 Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The extension of the file without the leading dot function pipen_filters.filters . prefix ( pth , ignore=[] , recursive=False ) </> Get the prefix of a file For example, /a/b/c.txt => /a/b/c Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The prefix of the file function pipen_filters.filters . prefix0 ( pth , ignore=[] , recursive=False ) </> Get the prefix of a file without the extension For example, /a/b/c.d.txt => /a/b/c.d Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The prefix of the file without the extension function pipen_filters.filters . filename ( pth , ignore=[] , recursive=False ) </> Get the filename of a file. For example, /a/b/c.d.txt => c.d . Aliases: fn , stem Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The filename of the file function pipen_filters.filters . filename0 ( pth , ignore=[] , recursive=False ) </> Get the filename of a file without the extension For example, /a/b/c.d.txt => c . Aliases: fn0 , stem0 Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The filename of the file without the extension function pipen_filters.filters . joinpaths ( pathsegment , *pathsegments ) </> Join paths. For example, joinpaths(\"a\", \"b\") => \"a/b\" . Aliases: joinpath Parameters pathsegment (str | os.pathlike) \u2014 The path to join *pathsegments (str | os.pathlike) \u2014 The paths to join Returns (str) The joined path function pipen_filters.filters . as_path ( pth ) </> Convert a path to a Path object Parameters pth (str | os.pathlike) \u2014 The path to convert Returns (pathlib.path | panpath.cloud.cloudpath) The Path object function pipen_filters.filters . isdir ( pth ) </> Check if a path is a directory Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a directory, False otherwise function pipen_filters.filters . isfile ( pth ) </> Check if a path is a file Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a file, False otherwise function pipen_filters.filters . islink ( pth ) </> Check if a path is a symlink Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a symlink, False otherwise function pipen_filters.filters . exists ( pth ) </> Check if a path exists Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path exists, False otherwise function pipen_filters.filters . getsize ( pth ) </> Get the size of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The size of the file function pipen_filters.filters . getmtime ( pth ) </> Get the modification time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The modification time of the file function pipen_filters.filters . getctime ( pth ) </> Get the creation time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The creation time of the file function pipen_filters.filters . getatime ( pth ) </> Get the access time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The access time of the file function pipen_filters.filters . isempty ( pth , ignore_ws=True , nonfile_as_empty=False ) </> Check if a file is empty Parameters pth (str | os.pathlike) \u2014 The path to the file ignore_ws (bool, optional) \u2014 Ignore whitespaces? nonfile_as_empty (bool, optional) \u2014 Treat non-file as empty? Returns (bool) True if the file is empty, False otherwise function pipen_filters.filters . quote ( var , quote_none=False ) </> Quote a string Parameters var (Any) \u2014 The string to quote quote_none (bool, optional) \u2014 Quote None as '\"None\"'?Otherwise, return 'None', without quotes Returns (str) The quoted string function pipen_filters.filters . squote ( var , quote_none=False ) </> Quote a string with single quotes Parameters var (Any) \u2014 The string to quote quote_none (bool, optional) \u2014 Quote None as \"'None'\"?Otherwise, return 'None', without quotes Returns (str) The quoted string function pipen_filters.filters . json_dumps ( var ) </> Dump an object to json. Aliases: json Parameters var (Any) \u2014 The object to dump Returns (str) The json string function pipen_filters.filters . json_load ( pth ) </> Load a json file Parameters pth (str | os.pathlike) \u2014 The path to the json file Returns (Any) The loaded object function pipen_filters.filters . json_loads ( jsonstr ) </> Load a json string to an object Parameters jsonstr (str) \u2014 The json string Returns (Any) The loaded object function pipen_filters.filters . toml ( var ) </> Dump an object to toml. Aliases: toml_dumps Parameters var (Any) \u2014 The object to dump Returns (str) The toml string function pipen_filters.filters . toml_load ( pth ) </> Load a toml file. null will be loaded as None Parameters pth (str | os.pathlike) \u2014 The path to the toml file Returns (Any) The loaded object function pipen_filters.filters . toml_loads ( tomlstr ) </> Load a toml string to an object, null will be loaded as None Parameters tomlstr (str) \u2014 The toml string Returns (Any) The loaded object function pipen_filters.filters . config ( x , loader=None ) </> Get the configuration (python dictionary) from a file Parameters x (Any) \u2014 The path to the file, dict or string of configurations (json or toml) loader (str, optional) \u2014 The loader to use, defaults to auto-detectIf x is a dict, this argument is ignored if x is a string and is not a file path, then x will be loaded as a toml string if loader is not specified if x is a file path, then x will be loaded according to the file extension Returns (Mapping) The config function pipen_filters.filters . glob ( pathsegment , *pathsegments ) </> Glob a path Parameters pathsegment (str | os.pathlike) \u2014 The path to glob *pathsegments (str | os.pathlike) \u2014 The paths to glob Returns (List) The globbed paths function pipen_filters.filters . glob0 ( *paths ) </> Glob a path and return the first result Parameters *paths (str | os.pathlike) \u2014 The paths to glob Returns (str) The first globbed path function pipen_filters.filters . read ( file , *args , **kwargs ) </> Read the contents from a file Parameters file (str | os.pathlike) \u2014 The path to the file *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments passed to open() Returns (Union) The contents of the file function pipen_filters.filters . readlines ( file , *args , **kwargs ) </> Read the lines from a file Parameters file (str | os.pathlike) \u2014 The path to the file *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments to open() Returns (Union) A list of lines in the file function pipen_filters.filters . regex_replace ( string , pattern , repl , count=0 , flags=0 ) </> Replace the matched pattern with a string Parameters string (str) \u2014 The string to search pattern (str) \u2014 The pattern to search repl (str) \u2014 The string to replace flags (int, optional) \u2014 The regex flags Returns (str) The replaced string function pipen_filters.filters . slugify ( string , *args , **kwargs ) </> Slugify a string Parameters string (str) \u2014 The string to slugify *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments to slugify() Returns (str) The slugified string","title":"pipen_filters.filters"},{"location":"api/pipen_filters.filters/#pipen_filtersfilters","text":"</> Provides the filters Functions add_filter ( aliases ) (Callable) \u2014 Add a filter to the FILTERS </> as_path ( pth ) (pathlib.path | panpath.cloud.cloudpath) \u2014 Convert a path to a Path object </> basename ( pth ) (str) \u2014 Get the basename of a path </> commonprefix ( *paths , basename_only ) (str) \u2014 Get the common prefix of a set of paths </> config ( x , loader ) (Mapping) \u2014 Get the configuration (python dictionary) from a file </> dirname ( pth ) (str) \u2014 Get the directory name of a path </> exists ( pth ) (bool) \u2014 Check if a path exists </> ext ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file </> ext0 ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file without the leading dot </> filename ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file. </> filename0 ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file without the extension </> getatime ( pth ) (int) \u2014 Get the access time of a file, return -1 if the file does not exist </> getctime ( pth ) (int) \u2014 Get the creation time of a file, return -1 if the file does not exist </> getmtime ( pth ) (int) \u2014 Get the modification time of a file, return -1 if the file does not exist </> getsize ( pth ) (int) \u2014 Get the size of a file, return -1 if the file does not exist </> glob ( pathsegment , *pathsegments ) (List) \u2014 Glob a path </> glob0 ( *paths ) (str) \u2014 Glob a path and return the first result </> isdir ( pth ) (bool) \u2014 Check if a path is a directory </> isempty ( pth , ignore_ws , nonfile_as_empty ) (bool) \u2014 Check if a file is empty </> isfile ( pth ) (bool) \u2014 Check if a path is a file </> islink ( pth ) (bool) \u2014 Check if a path is a symlink </> joinpaths ( pathsegment , *pathsegments ) (str) \u2014 Join paths. </> json_dumps ( var ) (str) \u2014 Dump an object to json. </> json_load ( pth ) (Any) \u2014 Load a json file </> json_loads ( jsonstr ) (Any) \u2014 Load a json string to an object </> prefix ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file </> prefix0 ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file without the extension </> quote ( var , quote_none ) (str) \u2014 Quote a string </> read ( file , *args , **kwargs ) (Union) \u2014 Read the contents from a file </> readlines ( file , *args , **kwargs ) (Union) \u2014 Read the lines from a file </> readlink ( pth ) (str) \u2014 Get the link of a symlink </> realpath ( pth ) (str) \u2014 Get the real path of a path </> regex_replace ( string , pattern , repl , count , flags ) (str) \u2014 Replace the matched pattern with a string </> slugify ( string , *args , **kwargs ) (str) \u2014 Slugify a string </> squote ( var , quote_none ) (str) \u2014 Quote a string with single quotes </> toml ( var ) (str) \u2014 Dump an object to toml. </> toml_load ( pth ) (Any) \u2014 Load a toml file. null will be loaded as None </> toml_loads ( tomlstr ) (Any) \u2014 Load a toml string to an object, null will be loaded as None </> function","title":"pipen_filters.filters"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersadd_filter","text":"</> Add a filter to the FILTERS Examples Filters added: myfilter >>> @add_filter ... def myfilter ( var ): ... return var >>> @add_filter () ... def myfilter ( var ): ... return var Filters added: myfilter , myfilter2 >>> @add_filter ( \"myfilter2\" ) ... def myfilter ( var ): ... return var Parameters aliases (Union, optional) \u2014 The aliases of the filter, the filter itself, or None Returns (Callable) The filter itself if used directly @add_filter ; orThe decorator to add the filter if used with arguments @add_filter(...) function","title":"pipen_filters.filters.add_filter"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersrealpath","text":"</> Get the real path of a path Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The real path of the file function","title":"pipen_filters.filters.realpath"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersreadlink","text":"</> Get the link of a symlink Parameters pth (str | os.pathlike) \u2014 The path to the symlink Returns (str) The link of the symlink function","title":"pipen_filters.filters.readlink"},{"location":"api/pipen_filters.filters/#pipen_filtersfilterscommonprefix","text":"</> Get the common prefix of a set of paths Examples >>> commonprefix ( \"/a/b/abc.txt\" , \"/a/b/abc.png\" ) >>> # \"abc.\" >>> commonprefix ( \"/a/b/abc.txt\" , \"/a/b/abc.png\" , basename_only = False ) >>> # \"/a/b/abc.\" Parameters *paths (str | os.pathlike) \u2014 The paths to find commonprefix agaist basename_only (bool, optional) \u2014 Only search on the basenames Returns (str) The common prefix of the paths function","title":"pipen_filters.filters.commonprefix"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersdirname","text":"</> Get the directory name of a path For example, /a/b/c.txt => /a/b/ Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The directory name of the file function","title":"pipen_filters.filters.dirname"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersbasename","text":"</> Get the basename of a path For example, /a/b/c.txt => c.txt Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (str) The basename of the file function","title":"pipen_filters.filters.basename"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersext","text":"</> Get the extension of a file For example, /a/b/c.txt => .txt . Aliases: suffix Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The extension of the file function","title":"pipen_filters.filters.ext"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersext0","text":"</> Get the extension of a file without the leading dot For example, /a/b/c.txt => txt . Aliases: suffix0 Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The extension of the file without the leading dot function","title":"pipen_filters.filters.ext0"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersprefix","text":"</> Get the prefix of a file For example, /a/b/c.txt => /a/b/c Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The prefix of the file function","title":"pipen_filters.filters.prefix"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersprefix0","text":"</> Get the prefix of a file without the extension For example, /a/b/c.d.txt => /a/b/c.d Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The prefix of the file without the extension function","title":"pipen_filters.filters.prefix0"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersfilename","text":"</> Get the filename of a file. For example, /a/b/c.d.txt => c.d . Aliases: fn , stem Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The filename of the file function","title":"pipen_filters.filters.filename"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersfilename0","text":"</> Get the filename of a file without the extension For example, /a/b/c.d.txt => c . Aliases: fn0 , stem0 Parameters pth (str | os.pathlike) \u2014 The path to the file ignore (list[str] | str, optional) \u2014 The extensions to ignoreThe extensions can be with or without leading dot recursive (bool, optional) \u2014 Recursively ignore the extensions from the end Returns (str) The filename of the file without the extension function","title":"pipen_filters.filters.filename0"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersjoinpaths","text":"</> Join paths. For example, joinpaths(\"a\", \"b\") => \"a/b\" . Aliases: joinpath Parameters pathsegment (str | os.pathlike) \u2014 The path to join *pathsegments (str | os.pathlike) \u2014 The paths to join Returns (str) The joined path function","title":"pipen_filters.filters.joinpaths"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersas_path","text":"</> Convert a path to a Path object Parameters pth (str | os.pathlike) \u2014 The path to convert Returns (pathlib.path | panpath.cloud.cloudpath) The Path object function","title":"pipen_filters.filters.as_path"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersisdir","text":"</> Check if a path is a directory Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a directory, False otherwise function","title":"pipen_filters.filters.isdir"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersisfile","text":"</> Check if a path is a file Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a file, False otherwise function","title":"pipen_filters.filters.isfile"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersislink","text":"</> Check if a path is a symlink Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path is a symlink, False otherwise function","title":"pipen_filters.filters.islink"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersexists","text":"</> Check if a path exists Parameters pth (str | os.pathlike) \u2014 The path to check Returns (bool) True if the path exists, False otherwise function","title":"pipen_filters.filters.exists"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersgetsize","text":"</> Get the size of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The size of the file function","title":"pipen_filters.filters.getsize"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersgetmtime","text":"</> Get the modification time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The modification time of the file function","title":"pipen_filters.filters.getmtime"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersgetctime","text":"</> Get the creation time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The creation time of the file function","title":"pipen_filters.filters.getctime"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersgetatime","text":"</> Get the access time of a file, return -1 if the file does not exist Parameters pth (str | os.pathlike) \u2014 The path to the file Returns (int) The access time of the file function","title":"pipen_filters.filters.getatime"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersisempty","text":"</> Check if a file is empty Parameters pth (str | os.pathlike) \u2014 The path to the file ignore_ws (bool, optional) \u2014 Ignore whitespaces? nonfile_as_empty (bool, optional) \u2014 Treat non-file as empty? Returns (bool) True if the file is empty, False otherwise function","title":"pipen_filters.filters.isempty"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersquote","text":"</> Quote a string Parameters var (Any) \u2014 The string to quote quote_none (bool, optional) \u2014 Quote None as '\"None\"'?Otherwise, return 'None', without quotes Returns (str) The quoted string function","title":"pipen_filters.filters.quote"},{"location":"api/pipen_filters.filters/#pipen_filtersfilterssquote","text":"</> Quote a string with single quotes Parameters var (Any) \u2014 The string to quote quote_none (bool, optional) \u2014 Quote None as \"'None'\"?Otherwise, return 'None', without quotes Returns (str) The quoted string function","title":"pipen_filters.filters.squote"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersjson_dumps","text":"</> Dump an object to json. Aliases: json Parameters var (Any) \u2014 The object to dump Returns (str) The json string function","title":"pipen_filters.filters.json_dumps"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersjson_load","text":"</> Load a json file Parameters pth (str | os.pathlike) \u2014 The path to the json file Returns (Any) The loaded object function","title":"pipen_filters.filters.json_load"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersjson_loads","text":"</> Load a json string to an object Parameters jsonstr (str) \u2014 The json string Returns (Any) The loaded object function","title":"pipen_filters.filters.json_loads"},{"location":"api/pipen_filters.filters/#pipen_filtersfilterstoml","text":"</> Dump an object to toml. Aliases: toml_dumps Parameters var (Any) \u2014 The object to dump Returns (str) The toml string function","title":"pipen_filters.filters.toml"},{"location":"api/pipen_filters.filters/#pipen_filtersfilterstoml_load","text":"</> Load a toml file. null will be loaded as None Parameters pth (str | os.pathlike) \u2014 The path to the toml file Returns (Any) The loaded object function","title":"pipen_filters.filters.toml_load"},{"location":"api/pipen_filters.filters/#pipen_filtersfilterstoml_loads","text":"</> Load a toml string to an object, null will be loaded as None Parameters tomlstr (str) \u2014 The toml string Returns (Any) The loaded object function","title":"pipen_filters.filters.toml_loads"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersconfig","text":"</> Get the configuration (python dictionary) from a file Parameters x (Any) \u2014 The path to the file, dict or string of configurations (json or toml) loader (str, optional) \u2014 The loader to use, defaults to auto-detectIf x is a dict, this argument is ignored if x is a string and is not a file path, then x will be loaded as a toml string if loader is not specified if x is a file path, then x will be loaded according to the file extension Returns (Mapping) The config function","title":"pipen_filters.filters.config"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersglob","text":"</> Glob a path Parameters pathsegment (str | os.pathlike) \u2014 The path to glob *pathsegments (str | os.pathlike) \u2014 The paths to glob Returns (List) The globbed paths function","title":"pipen_filters.filters.glob"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersglob0","text":"</> Glob a path and return the first result Parameters *paths (str | os.pathlike) \u2014 The paths to glob Returns (str) The first globbed path function","title":"pipen_filters.filters.glob0"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersread","text":"</> Read the contents from a file Parameters file (str | os.pathlike) \u2014 The path to the file *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments passed to open() Returns (Union) The contents of the file function","title":"pipen_filters.filters.read"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersreadlines","text":"</> Read the lines from a file Parameters file (str | os.pathlike) \u2014 The path to the file *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments to open() Returns (Union) A list of lines in the file function","title":"pipen_filters.filters.readlines"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersregex_replace","text":"</> Replace the matched pattern with a string Parameters string (str) \u2014 The string to search pattern (str) \u2014 The pattern to search repl (str) \u2014 The string to replace flags (int, optional) \u2014 The regex flags Returns (str) The replaced string function","title":"pipen_filters.filters.regex_replace"},{"location":"api/pipen_filters.filters/#pipen_filtersfiltersslugify","text":"</> Slugify a string Parameters string (str) \u2014 The string to slugify *args (Any) \u2014 and **kwargs (Any) \u2014 Other arguments to slugify() Returns (str) The slugified string","title":"pipen_filters.filters.slugify"},{"location":"api/pipen_filters/","text":"package pipen_filters </> Add a set of useful filters for pipen templates Classes TemplateOptsShortenFilter \u2014 Shorten the template opts in the log </> module pipen_filters . filters </> Provides the filters Functions add_filter ( aliases ) (Callable) \u2014 Add a filter to the FILTERS </> as_path ( pth ) (pathlib.path | panpath.cloud.cloudpath) \u2014 Convert a path to a Path object </> basename ( pth ) (str) \u2014 Get the basename of a path </> commonprefix ( *paths , basename_only ) (str) \u2014 Get the common prefix of a set of paths </> config ( x , loader ) (Mapping) \u2014 Get the configuration (python dictionary) from a file </> dirname ( pth ) (str) \u2014 Get the directory name of a path </> exists ( pth ) (bool) \u2014 Check if a path exists </> ext ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file </> ext0 ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file without the leading dot </> filename ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file. </> filename0 ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file without the extension </> getatime ( pth ) (int) \u2014 Get the access time of a file, return -1 if the file does not exist </> getctime ( pth ) (int) \u2014 Get the creation time of a file, return -1 if the file does not exist </> getmtime ( pth ) (int) \u2014 Get the modification time of a file, return -1 if the file does not exist </> getsize ( pth ) (int) \u2014 Get the size of a file, return -1 if the file does not exist </> glob ( pathsegment , *pathsegments ) (List) \u2014 Glob a path </> glob0 ( *paths ) (str) \u2014 Glob a path and return the first result </> isdir ( pth ) (bool) \u2014 Check if a path is a directory </> isempty ( pth , ignore_ws , nonfile_as_empty ) (bool) \u2014 Check if a file is empty </> isfile ( pth ) (bool) \u2014 Check if a path is a file </> islink ( pth ) (bool) \u2014 Check if a path is a symlink </> joinpaths ( pathsegment , *pathsegments ) (str) \u2014 Join paths. </> json_dumps ( var ) (str) \u2014 Dump an object to json. </> json_load ( pth ) (Any) \u2014 Load a json file </> json_loads ( jsonstr ) (Any) \u2014 Load a json string to an object </> prefix ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file </> prefix0 ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file without the extension </> quote ( var , quote_none ) (str) \u2014 Quote a string </> read ( file , *args , **kwargs ) (Union) \u2014 Read the contents from a file </> readlines ( file , *args , **kwargs ) (Union) \u2014 Read the lines from a file </> readlink ( pth ) (str) \u2014 Get the link of a symlink </> realpath ( pth ) (str) \u2014 Get the real path of a path </> regex_replace ( string , pattern , repl , count , flags ) (str) \u2014 Replace the matched pattern with a string </> slugify ( string , *args , **kwargs ) (str) \u2014 Slugify a string </> squote ( var , quote_none ) (str) \u2014 Quote a string with single quotes </> toml ( var ) (str) \u2014 Dump an object to toml. </> toml_load ( pth ) (Any) \u2014 Load a toml file. null will be loaded as None </> toml_loads ( tomlstr ) (Any) \u2014 Load a toml string to an object, null will be loaded as None </>","title":"pipen_filters"},{"location":"api/pipen_filters/#pipen_filters","text":"</> Add a set of useful filters for pipen templates Classes TemplateOptsShortenFilter \u2014 Shorten the template opts in the log </> module","title":"pipen_filters"},{"location":"api/pipen_filters/#pipen_filtersfilters","text":"</> Provides the filters Functions add_filter ( aliases ) (Callable) \u2014 Add a filter to the FILTERS </> as_path ( pth ) (pathlib.path | panpath.cloud.cloudpath) \u2014 Convert a path to a Path object </> basename ( pth ) (str) \u2014 Get the basename of a path </> commonprefix ( *paths , basename_only ) (str) \u2014 Get the common prefix of a set of paths </> config ( x , loader ) (Mapping) \u2014 Get the configuration (python dictionary) from a file </> dirname ( pth ) (str) \u2014 Get the directory name of a path </> exists ( pth ) (bool) \u2014 Check if a path exists </> ext ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file </> ext0 ( pth , ignore , recursive ) (str) \u2014 Get the extension of a file without the leading dot </> filename ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file. </> filename0 ( pth , ignore , recursive ) (str) \u2014 Get the filename of a file without the extension </> getatime ( pth ) (int) \u2014 Get the access time of a file, return -1 if the file does not exist </> getctime ( pth ) (int) \u2014 Get the creation time of a file, return -1 if the file does not exist </> getmtime ( pth ) (int) \u2014 Get the modification time of a file, return -1 if the file does not exist </> getsize ( pth ) (int) \u2014 Get the size of a file, return -1 if the file does not exist </> glob ( pathsegment , *pathsegments ) (List) \u2014 Glob a path </> glob0 ( *paths ) (str) \u2014 Glob a path and return the first result </> isdir ( pth ) (bool) \u2014 Check if a path is a directory </> isempty ( pth , ignore_ws , nonfile_as_empty ) (bool) \u2014 Check if a file is empty </> isfile ( pth ) (bool) \u2014 Check if a path is a file </> islink ( pth ) (bool) \u2014 Check if a path is a symlink </> joinpaths ( pathsegment , *pathsegments ) (str) \u2014 Join paths. </> json_dumps ( var ) (str) \u2014 Dump an object to json. </> json_load ( pth ) (Any) \u2014 Load a json file </> json_loads ( jsonstr ) (Any) \u2014 Load a json string to an object </> prefix ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file </> prefix0 ( pth , ignore , recursive ) (str) \u2014 Get the prefix of a file without the extension </> quote ( var , quote_none ) (str) \u2014 Quote a string </> read ( file , *args , **kwargs ) (Union) \u2014 Read the contents from a file </> readlines ( file , *args , **kwargs ) (Union) \u2014 Read the lines from a file </> readlink ( pth ) (str) \u2014 Get the link of a symlink </> realpath ( pth ) (str) \u2014 Get the real path of a path </> regex_replace ( string , pattern , repl , count , flags ) (str) \u2014 Replace the matched pattern with a string </> slugify ( string , *args , **kwargs ) (str) \u2014 Slugify a string </> squote ( var , quote_none ) (str) \u2014 Quote a string with single quotes </> toml ( var ) (str) \u2014 Dump an object to toml. </> toml_load ( pth ) (Any) \u2014 Load a toml file. null will be loaded as None </> toml_loads ( tomlstr ) (Any) \u2014 Load a toml string to an object, null will be loaded as None </>","title":"pipen_filters.filters"},{"location":"api/source/pipen_filters.filters/","text":"SOURCE CODE pipen_filters. filters DOCS \"\"\"Provides the filters\"\"\" from __future__ import annotations import json from functools import wraps from os import PathLike , path from pathlib import Path from typing import Any , List , Mapping , Union , Dict , Callable from diot import Diot from simpleconf import Config from simpleconf.caster import cast , null_caster from panpath import PanPath , CloudPath FILTERS : Dict [ str , Callable ] = {} def add_filter ( DOCS aliases : str | list [ str ] | Callable | None = None , ) -> Callable [[ Callable ], Callable ]: \"\"\"Add a filter to the FILTERS Examples: Filters added: `myfilter` >>> @add_filter ... def myfilter(var): ... return var >>> @add_filter() ... def myfilter(var): ... return var Filters added: `myfilter`, `myfilter2` >>> @add_filter(\"myfilter2\") ... def myfilter(var): ... return var Args: aliases: The aliases of the filter, the filter itself, or None Returns: The filter itself if used directly `@add_filter`; or The decorator to add the filter if used with arguments `@add_filter(...)` \"\"\" if callable ( aliases ): return add_filter ()( aliases ) aliases = aliases or [] if isinstance ( aliases , str ): aliases = [ aliases ] def _add_filter ( func : Callable ) -> Callable : FILTERS [ func . __name__ ] = func for alias in aliases : FILTERS [ alias ] = func return func return _add_filter def _neg1_if_error ( func : Callable ) -> Callable : \"\"\"Return -1 if an error occurs\"\"\" @wraps ( func ) def _func ( * args : Any , ** kwargs : Any ) -> int : try : return func ( * args , ** kwargs ) except Exception : return - 1 return _func def _splitexit ( pth : str | PathLike , ignore : list [ str ] | str , recursive : bool ) -> tuple [ str , str ]: \"\"\"Split the extension with leading dot of a file Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The path and the extension (with leading dot) \"\"\" if isinstance ( ignore , str ): ignore = [ ignore ] ignore = [ \".\" + ext . lstrip ( \".\" ) for ext in ignore ] pth , last = path . splitext ( str ( pth )) if not recursive : return ( pth , last ) if last not in ignore else path . splitext ( pth ) while last in ignore : pth , last = path . splitext ( pth ) return pth , last @add_filter DOCS def realpath ( pth : str | PathLike ) -> str : \"\"\"Get the real path of a path Args: pth: The path to the file Returns: The real path of the file \"\"\" return str ( PanPath ( pth ) . resolve ()) @add_filter DOCS def readlink ( pth : str | PathLike ) -> str : \"\"\"Get the link of a symlink Args: pth: The path to the symlink Returns: The link of the symlink \"\"\" return str ( PanPath ( pth ) . readlink ()) @add_filter DOCS def commonprefix ( * paths : str | PathLike , basename_only : bool = True ) -> str : \"\"\"Get the common prefix of a set of paths Examples: >>> commonprefix(\"/a/b/abc.txt\", \"/a/b/abc.png\") >>> # \"abc.\" >>> commonprefix(\"/a/b/abc.txt\", \"/a/b/abc.png\", basename_only=False) >>> # \"/a/b/abc.\" Args: *paths: The paths to find commonprefix agaist basename_only: Only search on the basenames Returns: The common prefix of the paths \"\"\" paths = [ PanPath ( pth ) . name if basename_only else str ( pth ) for pth in paths ] return path . commonprefix ( paths ) @add_filter DOCS def dirname ( pth : str | PathLike ) -> str : \"\"\"Get the directory name of a path For example, `/a/b/c.txt => /a/b/` Args: pth: The path to the file Returns: The directory name of the file \"\"\" return str ( PanPath ( pth ) . parent ) @add_filter DOCS def basename ( pth : str | PathLike ) -> str : \"\"\"Get the basename of a path For example, `/a/b/c.txt => c.txt` Args: pth: The path to the file Returns: The basename of the file \"\"\" return str ( PanPath ( pth ) . name ) @add_filter ( \"suffix\" ) DOCS def ext ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the extension of a file For example, `/a/b/c.txt => .txt`. Aliases: `suffix` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The extension of the file \"\"\" return _splitexit ( pth , ignore , recursive )[ 1 ] @add_filter ( \"suffix0\" ) DOCS def ext0 ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the extension of a file without the leading dot For example, `/a/b/c.txt => txt`. Aliases: `suffix0` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The extension of the file without the leading dot \"\"\" return ext ( pth , ignore , recursive )[ 1 :] @add_filter DOCS def prefix ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the prefix of a file For example, `/a/b/c.txt => /a/b/c` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The prefix of the file \"\"\" return _splitexit ( pth , ignore , recursive )[ 0 ] @add_filter DOCS def prefix0 ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the prefix of a file without the extension For example, `/a/b/c.d.txt => /a/b/c.d` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The prefix of the file without the extension \"\"\" return str ( PanPath ( pth ) . parent / FILTERS [ \"filename0\" ]( pth , ignore , recursive )) @add_filter ([ \"fn\" , \"stem\" ]) DOCS def filename ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the filename of a file. For example, `/a/b/c.d.txt => c.d`. Aliases: `fn`, `stem` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The filename of the file \"\"\" return basename ( _splitexit ( pth , ignore , recursive )[ 0 ]) @add_filter ([ \"fn0\" , \"stem0\" ]) DOCS def filename0 ( pth : str | PathLike , ignore : list [ str ] | str = [], recursive : bool = False , ) -> str : \"\"\"Get the filename of a file without the extension For example, `/a/b/c.d.txt => c`. Aliases: `fn0`, `stem0` Args: pth: The path to the file ignore: The extensions to ignore The extensions can be with or without leading dot recursive: Recursively ignore the extensions from the end Returns: The filename of the file without the extension \"\"\" return filename ( pth , ignore , recursive ) . split ( \".\" )[ 0 ] @add_filter ( \"joinpath\" ) DOCS def joinpaths ( pathsegment : str | PathLike , * pathsegments : str | PathLike ) -> str : \"\"\"Join paths. For example, `joinpaths(\"a\", \"b\") => \"a/b\"`. Aliases: `joinpath` Args: pathsegment: The path to join *pathsegments: The paths to join Returns: The joined path \"\"\" return str ( PanPath ( pathsegment ) . joinpath ( * pathsegments )) @add_filter DOCS def as_path ( pth : str | PathLike ) -> Path | CloudPath : \"\"\"Convert a path to a Path object Args: pth: The path to convert Returns: The Path object \"\"\" return PanPath ( str ( pth )) @add_filter DOCS def isdir ( pth : str | PathLike ) -> bool : \"\"\"Check if a path is a directory Args: pth: The path to check Returns: True if the path is a directory, False otherwise \"\"\" return PanPath ( pth ) . is_dir () @add_filter DOCS def isfile ( pth : str | PathLike ) -> bool : \"\"\"Check if a path is a file Args: pth: The path to check Returns: True if the path is a file, False otherwise \"\"\" return PanPath ( pth ) . is_file () @add_filter DOCS def islink ( pth : str | PathLike ) -> bool : \"\"\"Check if a path is a symlink Args: pth: The path to check Returns: True if the path is a symlink, False otherwise \"\"\" return PanPath ( pth ) . is_symlink () @add_filter DOCS def exists ( pth : str | PathLike ) -> bool : \"\"\"Check if a path exists Args: pth: The path to check Returns: True if the path exists, False otherwise \"\"\" return PanPath ( pth ) . exists () @add_filter DOCS @_neg1_if_error def getsize ( pth : str | PathLike ) -> int : \"\"\"Get the size of a file, return -1 if the file does not exist Args: pth: The path to the file Returns: The size of the file \"\"\" return PanPath ( pth ) . stat () . st_size @add_filter DOCS @_neg1_if_error def getmtime ( pth : str | PathLike ) -> int : \"\"\"Get the modification time of a file, return -1 if the file does not exist Args: pth: The path to the file Returns: The modification time of the file \"\"\" return PanPath ( pth ) . stat () . st_mtime @add_filter DOCS @_neg1_if_error def getctime ( pth : str | PathLike ) -> int : \"\"\"Get the creation time of a file, return -1 if the file does not exist Args: pth: The path to the file Returns: The creation time of the file \"\"\" return PanPath ( pth ) . stat () . st_ctime @add_filter DOCS @_neg1_if_error def getatime ( pth : str | PathLike ) -> int : \"\"\"Get the access time of a file, return -1 if the file does not exist Args: pth: The path to the file Returns: The access time of the file \"\"\" return PanPath ( pth ) . stat () . st_atime @add_filter DOCS def isempty ( pth : str | PathLike , ignore_ws : bool = True , nonfile_as_empty : bool = False , ) -> bool : \"\"\"Check if a file is empty Args: pth: The path to the file ignore_ws: Ignore whitespaces? nonfile_as_empty: Treat non-file as empty? Returns: True if the file is empty, False otherwise \"\"\" pth = PanPath ( pth ) if not pth . is_file (): return nonfile_as_empty if not ignore_ws : return getsize ( pth ) == 0 return pth . read_text () . strip () == \"\" @add_filter DOCS def quote ( var : Any , quote_none : bool = False ) -> str : \"\"\"Quote a string Args: var: The string to quote quote_none: Quote None as '\"None\"'? Otherwise, return 'None', without quotes Returns: The quoted string \"\"\" if var is None and not quote_none : return 'None' return json . dumps ( str ( var )) @add_filter DOCS def squote ( var : Any , quote_none : bool = False ) -> str : \"\"\"Quote a string with single quotes Args: var: The string to quote quote_none: Quote None as \"'None'\"? Otherwise, return 'None', without quotes Returns: The quoted string \"\"\" if var is None and not quote_none : return 'None' return repr ( str ( var )) @add_filter ( \"json\" ) DOCS def json_dumps ( var : Any ) -> str : \"\"\"Dump an object to json. Aliases: `json` Args: var: The object to dump Returns: The json string \"\"\" return json . dumps ( var ) @add_filter DOCS def json_load ( pth : str | PathLike ) -> Any : \"\"\"Load a json file Args: pth: The path to the json file Returns: The loaded object \"\"\" return config ( pth , \"json\" ) @add_filter DOCS def json_loads ( jsonstr : str ) -> Any : \"\"\"Load a json string to an object Args: jsonstr: The json string Returns: The loaded object \"\"\" return json . loads ( jsonstr ) @add_filter ( \"toml_dumps\" ) DOCS def toml ( var : Any ) -> str : \"\"\"Dump an object to toml. Aliases: `toml_dumps` Args: var: The object to dump Returns: The toml string \"\"\" return Diot ( var ) . to_toml () @add_filter DOCS def toml_load ( pth : str | PathLike ) -> Any : \"\"\"Load a toml file. `null` will be loaded as None Args: pth: The path to the toml file Returns: The loaded object \"\"\" return config ( pth , \"toml\" ) @add_filter DOCS def toml_loads ( tomlstr : str ) -> Any : \"\"\"Load a toml string to an object, `null` will be loaded as None Args: tomlstr: The toml string Returns: The loaded object \"\"\" return cast ( Config . load ( tomlstr , loader = \"tomls\" ), [ null_caster ]) @add_filter DOCS def config ( x : Any , loader : str = None ) -> Mapping [ str , Any ]: \"\"\"Get the configuration (python dictionary) from a file Args: x: The path to the file, dict or string of configurations (json or toml) loader: The loader to use, defaults to auto-detect If x is a dict, this argument is ignored if x is a string and is not a file path, then x will be loaded as a toml string if loader is not specified if x is a file path, then x will be loaded according to the file extension Returns: The config \"\"\" if not isinstance ( x , ( Path , str )): # assume dict return Config . load_one ( x , loader = \"dict\" ) if isinstance ( x , str ) and not PanPath ( x ) . is_file (): if loader == \"toml\" : return Diot ( FILTERS [ \"toml_loads\" ]( x )) if loader == \"json\" : return Diot ( FILTERS [ \"json_loads\" ]( x )) raise ValueError ( f \"Unknown loader: { loader } \" ) return Config . load_one ( x , loader = loader ) @add_filter DOCS def glob ( pathsegment : str | PathLike , * pathsegments : str | PathLike ) -> List [ str ]: \"\"\"Glob a path Args: pathsegment: The path to glob *pathsegments: The paths to glob Returns: The globbed paths \"\"\" return list ( sorted ([ str ( p ) for p in PanPath ( pathsegment ) . glob ( \"/\" . join ( pathsegments ))]) ) @add_filter DOCS def glob0 ( * paths : str | PathLike ) -> str : \"\"\"Glob a path and return the first result Args: *paths: The paths to glob Returns: The first globbed path \"\"\" return glob ( * paths )[ 0 ] @add_filter DOCS def read ( file : str | PathLike , * args : Any , ** kwargs : Any ) -> Union [ str , bytes ]: \"\"\"Read the contents from a file Args: file: The path to the file *args: and **kwargs: Other arguments passed to `open()` Returns: The contents of the file \"\"\" with PanPath ( file ) . open ( * args , ** kwargs ) as fvar : return fvar . read () @add_filter DOCS def readlines ( file : str | PathLike , * args : Any , ** kwargs : Any , ) -> Union [ List [ str ], List [ bytes ]]: \"\"\"Read the lines from a file Args: file: The path to the file *args: and **kwargs: Other arguments to `open()` Returns: A list of lines in the file \"\"\" return read ( file , * args , ** kwargs ) . splitlines () @add_filter DOCS def regex_replace ( string : str , pattern : str , repl : str , count : int = 0 , flags : int = 0 , ) -> str : \"\"\"Replace the matched pattern with a string Args: string: The string to search pattern: The pattern to search repl: The string to replace flags: The regex flags Returns: The replaced string \"\"\" import re return re . sub ( pattern , repl , string , count = count , flags = flags ) @add_filter DOCS def slugify ( string : str , * args : Any , ** kwargs : Any ) -> str : \"\"\"Slugify a string Args: string: The string to slugify *args: and **kwargs: Other arguments to `slugify()` Returns: The slugified string \"\"\" from slugify import slugify as _slugify return _slugify ( string , * args , ** kwargs )","title":"pipen_filters.filters"},{"location":"api/source/pipen_filters/","text":"SOURCE CODE pipen_filters DOCS \"\"\"Add a set of useful filters for pipen templates\"\"\" import logging from typing import TYPE_CHECKING from pipen import plugin from pipen.utils import logger from .filters import FILTERS if TYPE_CHECKING : # pragma: no cover from pipen import Pipen __version__ = \"1.1.2\" class PipenFilters : __version__ : str = __version__ @plugin . impl async def on_init ( pipen : \"Pipen\" ) -> None : # type: ignore \"\"\"Add the filters\"\"\" config = pipen . config if \"template_opts\" not in config : # pragma: no cover config . template_opts = {} if \"filters\" not in config . template_opts : config . template_opts . filters = {} if \"globals\" not in config . template_opts : config . template_opts . globals = {} config . template_opts . filters = { ** FILTERS , ** config . template_opts . filters , } config . template_opts . globals = { ** FILTERS , ** config . template_opts . globals , } class TemplateOptsShortenFilter ( logging . Filter ): DOCS \"\"\"Shorten the template opts in the log\"\"\" def filter ( self , record : logging . LogRecord ) -> bool : DOCS if ( record . msg == \"[bold][magenta] %-16s :[/magenta][/bold] %s \" and isinstance ( record . args , tuple ) and len ( record . args ) == 2 and ( record . args [ 0 ] == \"template_opts\" or ( not record . args [ 0 ] and ( isinstance ( record . args [ 1 ], str ) and record . args [ 1 ][: 8 ] in ( \"filters=\" , \"globals=\" ) ) ) ) ): record . msg = \"[bold][magenta] %-16s :[/magenta][/bold] %.54s ...\" return True logger . logger . addFilter ( TemplateOptsShortenFilter ())","title":"pipen_filters"}]}